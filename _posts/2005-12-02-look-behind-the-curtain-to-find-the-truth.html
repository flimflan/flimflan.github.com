---
title: Look behind the curtain to find the truth
permalink: LookBehindTheCurtainToFindTheTruth.html
layout: migrated
date: 2005-12-02
id: 3a2faf64-23d4-493b-b2c4-7df78e92ccde
published_at: 2005-12-02 18:30:21.234375000 -06:00

---

<P>Sometimes a question will come up about the preferred way to write some code. There are always multiple ways to accomplish the same goals, but some ways are better than others. Of course, that depends on how you define "better": most performant, lowest resource usage, maintainability, easiest to read, etc. Once you decide what you are looking for, you need a way to compare different solutions.</P>
<P>In a recent code review it was suggested that it was better to declare a variable outside of a loop, if it is going to be used repeatedly within the loop. The current code had the variable declared within the loop, so that the variable is declared for every iteration. The reviewer suggested that this would create unnecessary performance or resource overhead. Others suggested&nbsp;that there wouldn't be any difference at all, that it was really just a question of style. Each side had their theories and explanations, but neither could convince the other definitively. Everyone understood that in this instance&nbsp;the performance difference, if any, would be negligible, so it wasn't really a big deal, and the review continued on to the next topic.</P>
<P>However, in other situations, knowing how to answer this kind of question might be important. This article will walk through how I resolved this issue, not because the answer is important, but because I think there is value in knowing how to find the answer.</P>
<P>The easiest way to resolve this issue is to just look at the MSIL (<A href="http://msdn.microsoft.com/netframework/programming/clr/default.aspx">Microsoft Intermediate Language</A>) code. All .NET code, no matter what language (C#, VB.NET, J#, etc) gets compiled into MSIL. The .NET Runtime doesn't know about C# or VB.NET, it only knows how to execute MSIL. MSIL is the code that is truly executed; a language like C# is just a nicer way to write the code.</P>
<P>For these types of tasks, I like to drop down to a command-prompt, and leave behind the dream world of Visual Studio, with its candy coated syntax highlighting, and intellisense narcotics. I want to know what is REALLY going on, without risking the chance that a tool will do some magic for me automatically.</P>
<P>You can use the Visual Studio Command Prompt on your start menu, or just open a command prompt and set your PATH to include the .NET Framework SDK folder (c:\Program Files\Microsoft Visual Studio .NET 2003\SDK\v1.1\bin). Open a new file in notepad:</P><SPAN style="PADDING-RIGHT: 3px; PADDING-LEFT: 3px; COLOR: #c0c0c0; FONT-FAMILY: 'lucinda console',monospace; BACKGROUND-COLOR: black">c:\code&gt;notepad samplelib.cs</SPAN> 
<P>Write the following code in Notepad. Save and close to&nbsp;return to the command prompt.</P>
<P style="BACKGROUND-COLOR: #ffffe0"><FONT face="Courier New" size=2>class Sample {<BR>&nbsp; private string[] colors = new string[]{"Red","Green","Blue","Yellow","Orange"};<BR><BR>&nbsp; public void DeclareOutsideLoop(){<BR>&nbsp;&nbsp;&nbsp; string myvariable;<BR>&nbsp;&nbsp;&nbsp; for(int i=0; i&lt;colors.Length; ++i){<FONT face="Courier New" size=2><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myvariable = colors[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(myvariable);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp; }<BR><BR>&nbsp; public void DeclareInsideLoop(){<BR>&nbsp;&nbsp;&nbsp; for(int i=0; i&lt;colors.Length; i++){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string myvariable = colors[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(myvariable);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp; }<BR>}</FONT></P>
<P>Now compile the code into a DLL using the C# compilier (<A href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cscomp/html/vcrefcsharpcompileroptionsbycategory.asp?frame=true">CSC.EXE</A>) included on every machine with the .NET Runtime:</P><SPAN style="PADDING-RIGHT: 3px; PADDING-LEFT: 3px; COLOR: #c0c0c0; FONT-FAMILY: 'lucinda console',monospace; BACKGROUND-COLOR: black">c:\code&gt;csc /target:library /out:simplelib.dll simplelib.cs</SPAN> 
<P>You now have a compiled .NET assembly which contains a class with 2 methods that accomplish the same thing, but use slightly different C# code (one declares the temp variable within the loop, one declares it outside of the loop). You can view the IL code for the assembly (or any .NET assembly) using the IL Disassembler (<A href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cptools/html/cpconmsildisassemblerildasmexe.asp?frame=true">ILDASM.EXE</A>), included on every machine with the .NET SDK.</P><SPAN style="PADDING-RIGHT: 3px; PADDING-LEFT: 3px; COLOR: #c0c0c0; FONT-FAMILY: 'lucinda console',monospace; BACKGROUND-COLOR: black">c:\code&gt;ildasm simplelib.dll</SPAN> 
<P>In the ILDASM window, you will see the Sample class. If you click on the plus sign to expand the class, you will see each of the method names. If you double-click on a method name, you will see the MSIL code that makes up the method. This is the contents of DeclareOutsideLoop:</P>
<P style="BACKGROUND-COLOR: #ffffe0"><FONT face="Courier New" size=2>.method public hidebysig instance void&nbsp; DeclareOutsideLoop() cil managed<BR>{<BR>&nbsp; // Code size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 35 (0x23)<BR>&nbsp; .maxstack&nbsp; 2<BR>&nbsp; .locals init (string V_0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32 V_1)<BR>&nbsp; IL_0000:&nbsp; ldc.i4.0<BR>&nbsp; IL_0001:&nbsp; stloc.1<BR>&nbsp; IL_0002:&nbsp; br.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IL_0017<BR>&nbsp; IL_0004:&nbsp; ldarg.0<BR>&nbsp; IL_0005:&nbsp; ldfld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string[] Sample::colors<BR>&nbsp; IL_000a:&nbsp; ldloc.1<BR>&nbsp; IL_000b:&nbsp; ldelem.ref<BR>&nbsp; IL_000c:&nbsp; stloc.0<BR>&nbsp; IL_000d:&nbsp; ldloc.0<BR>&nbsp; IL_000e:&nbsp; call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void [mscorlib]System.Console::WriteLine(string)<BR>&nbsp; IL_0013:&nbsp; ldloc.1<BR>&nbsp; IL_0014:&nbsp; ldc.i4.1<BR>&nbsp; IL_0015:&nbsp; add<BR>&nbsp; IL_0016:&nbsp; stloc.1<BR>&nbsp; IL_0017:&nbsp; ldloc.1<BR>&nbsp; IL_0018:&nbsp; ldarg.0<BR>&nbsp; IL_0019:&nbsp; ldfld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string[] Sample::colors<BR>&nbsp; IL_001e:&nbsp; ldlen<BR>&nbsp; IL_001f:&nbsp; conv.i4<BR>&nbsp; IL_0020:&nbsp; blt.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IL_0004<BR>&nbsp; IL_0022:&nbsp; ret<BR>} // end of method Sample::DeclareOutsideLoop</FONT></P>
<P>And this is the contents of DeclareInsideLoop:</P>
<P style="BACKGROUND-COLOR: #ffffe0"><FONT face="Courier New" size=2>.method public hidebysig instance void&nbsp; DeclareInsideLoop() cil managed<BR>{<BR>&nbsp; // Code size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 35 (0x23)<BR>&nbsp; .maxstack&nbsp; 2<BR>&nbsp; .locals init (<FONT color=#ff0000>int32 V_0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string V_1</FONT>)<BR>&nbsp; IL_0000:&nbsp; ldc.i4.0<BR>&nbsp; IL_0001:&nbsp; stloc.<FONT color=#ff0000>0</FONT><BR>&nbsp; IL_0002:&nbsp; br.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IL_0017<BR>&nbsp; IL_0004:&nbsp; ldarg.0<BR>&nbsp; IL_0005:&nbsp; ldfld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string[] Sample::colors<BR>&nbsp; IL_000a:&nbsp; ldloc.<FONT color=#ff0000>0</FONT><BR>&nbsp; IL_000b:&nbsp; ldelem.ref<BR>&nbsp; IL_000c:&nbsp; stloc.<FONT color=#ff0000>1</FONT><BR>&nbsp; IL_000d:&nbsp; ldloc.<FONT color=#ff0000>1</FONT><BR>&nbsp; IL_000e:&nbsp; call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void [mscorlib]System.Console::WriteLine(string)<BR>&nbsp; IL_0013:&nbsp; ldloc.<FONT color=#ff0000>0</FONT><BR>&nbsp; IL_0014:&nbsp; ldc.i4.1<BR>&nbsp; IL_0015:&nbsp; add<BR>&nbsp; IL_0016:&nbsp; stloc.<FONT color=#ff0000>0</FONT><BR>&nbsp; IL_0017:&nbsp; ldloc.<FONT color=#ff0000>0</FONT><BR>&nbsp; IL_0018:&nbsp; ldarg.0<BR>&nbsp; IL_0019:&nbsp; ldfld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string[] Sample::colors<BR>&nbsp; IL_001e:&nbsp; ldlen<BR>&nbsp; IL_001f:&nbsp; conv.i4<BR>&nbsp; IL_0020:&nbsp; blt.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IL_0004<BR>&nbsp; IL_0022:&nbsp; ret<BR>} // end of method Sample::DeclareInsideLoop<BR></FONT></P>
<P>The differences are highlighted in <FONT color=#ff0000>red</FONT>. As you would expect, the methods are very similar. The key is in the method meta-data. Notice that they both declare maxstack 2, which means they both will only have at most 2 items on the stack. The next line shows the local variables that are used. DeclareInsideLoop defines a string, and then an int32. DeclareOutsideLoop defines an int32, and the a string. So they both use the same number and type of variables, they are just declared in a different order. It is this difference in order that accounts for the remaining differences in the code. In one method, the string (myvariable) is at stack offset 0, in the other method, it is at stack offset 1. In one method, the int32 (the iteration variable i) is at offset 1, and in the other method it is at stack offset 0.</P>
<P>This tells us conclusively that there will be absolutely no difference in execution behavior between the 2 methods - neither method uses more variables, object, pointers, or instructions than the other. There is no performance reason for choosing one over the other.</P></FONT>

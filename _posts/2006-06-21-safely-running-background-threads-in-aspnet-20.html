---
title: Safely running background threads in ASP.NET 2.0
permalink: SafelyRunningBackgroundThreadsInASPNET20.html
layout: migrated
date: 2006-06-21
id: b50b7d3a-d81d-462e-aece-72298bce00e2
published_at: 2006-06-21 21:50:02.857000000 -05:00
tags: .NET

---

The .NET Framework 2.0 no longer allows background threads to die silently when an unhandled exception is thrown. I'm not going to dive into the details of the change, as it is already well-documented on the web (<a href="http://www.julmar.com/blog/mark/PermaLink,guid,f733e261-5d39-4ca1-be1a-c422f3cf1f1b.aspx">this post describes the behavior for different application types</a> &amp; <a href="http://odetocode.com/Blogs/scott/archive/2005/12/14/2618.aspx">Scott Allen focuses on the ASP.NET impact</a>).<br /><br /><span style="font-weight: bold;">The impact is more significant for ASP.NET applications</span><br />I think this is actually a bigger change for ASP.NET apps, because it has always had a &quot;safety net&quot;. In console/WinForms applications, if there is an unhandled exception on the <span style="font-style: italic;">primary </span>thread, the application dies. Having your application die now because of an unhandled exception on a <span style="font-style: italic;">background </span>thread is not that big of a difference. You have an unhandled exception in your application, the application dies. Consistent.<br /><br />However, in ASP.NET, exceptions that you did not handle in your own code on the <span style="font-style: italic;">primary </span>thread were always caught by a default handler (affectionately known as the &quot;<a href="http://en.wikipedia.org/wiki/Yellow_screen_of_death">yellow screen of death</a>&quot;). Your application did not die. You could add a handler for the HttpApplication.Error event (Application_Error in global.asax) to centralize your exception handling and logging logic. In 1.x, exceptions that occurred on a background thread would die silently. Your application did not die. Consistent. But now, in 2.0, exceptions on your primary thread still do not kill your application, and can be logged by your global handler. But exceptions on your background threads will kill your application, and will not be logged.<br /><br /><span style="font-weight: bold;">My approach to exception handling and how it is now more difficult to implement</span><br />My philosophy is to never catch exceptions unless there is something I can do to address the issue. I prefer not to catch all possible exceptions throughout the internals of my code, and instead rely on try...finally blocks to clean up in case of an exception, and allow the exception to bubble up to a top-level handler where it can be logged (of course I catch exceptions when there is something the code can do to resolve the issue or continue in a known state).<br /><br />The new background thread exception behavior forces me to create &quot;top level handler and logging&quot; code for the application (global.asax) AND within every method that I run on a background thread. I end up with a lot of duplicate code, and explicit exception handling and logging that I would prefer to be hidden behind the scenes instead of cluttering up my application logic.<br /><br /><span style="font-weight: bold;">A proposed solution</span><br />My goals:<br />
<ul>
    <li>Allow unexpected exceptions on all threads to be logged by a top level exception handler</li>
    <li>Do not let the application die because of an exception, no matter which thread it is running on (at least not before I get a chance to log it).</li>
    <li>Do not clutter the application logic with repeated try..catch and logging code.</li>
</ul>
To satisfy the top level exception handler goal, I would like to make use of the existing HttpApplication.Error / Application_Error mechanism. That means I need to somehow transfer the exception that occurred on a background thread to a primary ASP.NET thread. To satisfy the &quot;do not die&quot; and &quot;do not clutter&quot; goals, I need to wrap all calls to background thread methods with a single piece of code.<br /><br />I've created the <span style="font-family: 'courier new',courier; font-size: x-small;">SafeWaitCallback </span>class. It's <span style="font-family: 'courier new',courier; font-size: x-small;">Call </span>method is used in place of a <span style="font-family: 'courier new',courier; font-size: x-small;">WaitCallback </span>delegate. For example, if I want to execute the method <span style="font-family: 'courier new',courier; font-size: x-small;">DoTask </span>on a background thread, I would call it like this:<br />
<p><span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px;">System.Threading.ThreadPool.QueueUserWorkItem(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> SafeWaitCallback().Call(DoTask));</span></p>
SafeWaitCallback does two things: it wraps calls to the target method in a try...catch block, and it forwards the caught exception to a custom HttpHandler. It forwards the exception by serializing it to a byte array, and then POSTing it to the handler, which will receive the bytes and deserialize back to an Exception object.<br /><br />
<p><span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px;"><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System;<br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System.Net;<br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System.IO;<br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System.Runtime.Serialization.Formatters.Binary;<br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System.Runtime.Serialization;<br /><br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">class</span> SafeWaitCallback {<br />&nbsp; <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">static</span> Uri ApplicationUri;<br />&nbsp; System.Threading.WaitCallback callback;<br /><br />&nbsp; <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> System.Threading.WaitCallback Call(System.Threading.WaitCallback callback) {<br />&nbsp;&nbsp;&nbsp; <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">this</span>.callback <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> callback;<br />&nbsp;&nbsp;&nbsp;    <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">return</span> CallbackWrapper;<br />&nbsp; }<br /><br />&nbsp; <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">private</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">void</span> CallbackWrapper(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">object</span> state) {<br />&nbsp;&nbsp;&nbsp;    <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">try</span><br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callback(state);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">catch</span> (Exception e)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">byte</span>[] exceptionData;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemoryStream stream <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> MemoryStream();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryFormatter formatter <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> BinaryFormatter(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">null</span>, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> StreamingContext(StreamingContextStates.Persistence));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; formatter.Serialize(stream, e);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exceptionData <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> stream.ToArray();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WebClient client <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> WebClient();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uri handler <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> Uri(ApplicationUri, <span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">&quot;TransferException.axd&quot;</span>);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">try</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; client.UploadData(handler, exceptionData);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">catch</span> (WebException) { }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />}<br /></span></p>
By forwarding the exception to the custom HttpHandler, I can re-raise the exception, and since the handler will be running on a primary ASP.NET thread (not in the background), the exception will be caught by my global handler, and logged just like any other exception.<br />
<p><span style="color: Black; background-color: transparent; font-family: Courier New; font-size: 11px;"><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System;<br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System.Web;<br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System.IO;<br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System.Runtime.Serialization.Formatters.Binary;<br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">using</span> System.Runtime.Serialization;<br /><br /><span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">class</span> TransferredExceptionHandler : IHttpHandler {<br />&nbsp;    <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">bool</span> IsReusable { get { <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">return</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">true</span>; }}<br /><br />&nbsp;    <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">public</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">void</span> ProcessRequest(HttpContext context) {<br />&nbsp;&nbsp;&nbsp;        <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">byte</span>[] exceptionData <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">byte</span>[context.Request.ContentLength];<br />&nbsp;&nbsp;&nbsp; context.Request.InputStream.Read(exceptionData, 0, exceptionData.Length);<br /><br />&nbsp;&nbsp;&nbsp; Exception transferredException;<br />&nbsp;&nbsp;&nbsp; MemoryStream stream <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> MemoryStream(exceptionData);<br />&nbsp;&nbsp;&nbsp; BinaryFormatter formatter <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> BinaryFormatter(<span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">null</span>, <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> StreamingContext(StreamingContextStates.Persistence));<br />&nbsp;&nbsp;&nbsp; transferredException <span style="color: Red; background-color: transparent; font-family: Courier New; font-size: 11px;">=</span> (Exception)formatter.Deserialize(stream);<br />&nbsp;&nbsp;&nbsp; <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">throw</span> <span style="color: Blue; background-color: transparent; font-family: Courier New; font-size: 11px;">new</span> Exception(<span style="color: rgb(102, 102, 102); background-color: rgb(228, 228, 228); font-family: Courier New; font-size: 11px;">&quot;[Background exception transferred - see InnerException]&quot;</span>, transferredException);<br />&nbsp; }<br />}</span></p>
The handler is registered in web.config with the following entry:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;httpHandlers&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;add verb=&quot;POST&quot; path=&quot;TransferException.axd&quot; type=&quot;TransferredExceptionHandler&quot; /&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/httpHandlers&gt;<br /><br /><span style="font-weight: bold;">Let me know what you think</span><br />I've attached the full source code in the form of a Web Site project. It includes a Default.aspx page which demonstrates the different scenarios of an unhandled exception (primary thread, background thread, &quot;safe&quot; background thread using my new code).<br /><br />This is <span style="font-style: italic;">not</span> production ready code, it is still in the proof of concept stage. For one, it probably needs better exception handling within the CallbackWrapper exception handler (what if the serialization blows up?). More importantly, I'm not yet convinced this whole idea is a worthwhile approach. It meets my goals, but it feels a little hackish. I wanted to see if it was possible, and then throw it out there to get some feedback. Anyone see any major flaws in the concept? Even better, does anyone know of a more elegant approach to achieve the same goals?<br />
<p><a href="/assets/post_images/AspNetBackgroundExceptions.zip">Download AspNetBackgroundExceptions.zip (2.55 KB)</a></p>

---
title: The power of yield (return)
permalink: ThePowerOfYieldreturn.html
layout: migrated
date: 2008-02-03
dasblog_id: 6bf33a2f-209e-4f1f-8e73-51e0e4ee2f77
published_at: 2008-02-03 12:02:09.358625000 -06:00
comments:
- created: 2008-02-03 14:46:30.264875000 -06:00
  author: Chad Myers
  email: chad@chadmyers.com
  url: http://chadmyers.lostechies.com
  content: ! 'Side note (C# trivia): the foreach() keyword actually doesn''t require
    IEnumerable, it only requires an object that has a method called ''GetEnumerator()''
    that returns an IEnumerator instance.'
- created: 2008-02-04 12:03:59.108625000 -06:00
  author: Steve Campbell
  email: dukeytoo@gmail.com
  url: http://blog.perfectapi.com
  content: ! 'Thanks Joshua, that''s great to know.  FYI: For me, the Demonstration
    section was unnecessary (too hard to follow) - I got what I needed to know from
    the code sample.'
- created: 2008-02-04 20:34:48.796125000 -06:00
  author: Joshua Flanagan
  email: josh@flimflan.com
  url: http://flimflan.com/blog
  content: ! '@Chad - I know, isn''t that funky? ;) I always struggle with how many
    of these side thoughts I should include in a post, but I was trying really hard
    to keep this focused, so that it would be approachable to beginners. But I''m
    glad you brought it up, so the full story gets told!


    @Steve - Thanks, that''s exactly the kind of feedback I look for.'
- created: 2008-02-05 16:05:13.139875000 -06:00
  author: Bart Czernicki
  email: rev4bart@aol.com
  content: ! 'There is also a great demo of the keyword in the book &quot;LINQ in
    Action&quot;..showing how you can parse a big file without reading it all into
    memory.  Pretty cool.


    Since we are on fun facts...using foreach actually leaves behind an object that
    needs to be gc''ed.  So, that is why foreach is not used in game programming (for
    loops are &quot;usually&quot; better and leave nothing to be cleaned up).  Something
    I learned when I was dabbling with the XNA framework for the XBOX 360.'
- created: 2008-02-06 03:55:33.280500000 -06:00
  author: mike
  email: mike@mike.com
  content: So why is it better to return IList&lt;T&gt; than List&lt;T&gt;?
- created: 2008-02-06 04:55:42.546125000 -06:00
  author: Shane
  email: shane@freshclickmedia.com
  url: http://www.freshclickmedia.com
  content: ! 'Interesting article.  I guess it''s inevitable that people miss out
    some language features and focus on some of the more ''sexy'' aspects of 3.5.


    The performance gain using yield is a compelling reason for me to explore it.  I''m
    going to copy that source code and run it through myself now.


    Thanks.'
- created: 2008-02-06 06:23:30.811750000 -06:00
  author: Rob
  email: robert_s_eRemoveThis4Wordsllis@yahoo.com
  content: ! '@ Shane


    It''s not better to return an (IList&lt;t&gt;), it''s better to accept IList&lt;T&gt;
    as a return parameter.  That way you can return any object that supports the IList&lt;T&gt;
    interface rather than ONLY List&lt;T&gt;.  The benefit is in code maintenance
    so that if you want to refactor something, you may not have to alter all of its
    dependencies.


    Rob'
- created: 2008-02-06 06:36:31.014875000 -06:00
  author: Eric
  email: eric@ericjohansson.se
  url: http://blog.ericjohansson.se
  content: I noticed that you never printed Ending execution of BetterGetCombinations,
    since it never returned to BetterGetCombinations after the break statement. How
    would you suggest dealing with, for example, open database connections? Overall
    though, a very interesting article
- created: 2008-02-06 07:23:36.983625000 -06:00
  author: Mike
  content: ! '@Eric


    If you put cleanup code in a finally block it should work (at least it made &quot;Ending
    execution of BetterGetCombinations&quot; print), though you will encounter extra
    overhead.'
- created: 2008-02-06 12:25:10.889875000 -06:00
  author: Marc Ziss
  email: marc@zconsulting.com
  content: ! "Excellent explanation of the counter intuitive split execution of yield
    vs the standard linear method. \nPs Yield also works with the non-generic version
    of IEnumerable in case you're returning a collection that doesn't necessarily
    need to be locked down, because it may return multiple shapes to be consumed by
    a templated control like a gridview"
- created: 2008-02-07 02:16:25.093000000 -06:00
  author: Peter G
  email: nameless@blah.com
  content: ! 'Good intro. I am an occasional Dot Net developer and just want to add
    a gratuitous plug here for the idea that one should as a matter of principle immerse
    oneself in the details of more than one programming paradigm.


    The yield thingy  is nothing new to Python and Ruby programmers. Similarly, a
    familiarity with list comprehensions (Haskell, Python) would stand anyone starting
    out with LINQ in good stead.


    Obviously anybody with an ear to the ground would also be well-advised to poke
    their noses into Don Syme''s F# book this year.


    For some good examples of yield goodness, I suggest googling for Python or Ruby
    combinatoric generators - e.g. k-subsets. For a C# version, see here:  http://www.interact-sw.co.uk/iangblog/2004/09/16/permuterate'
- created: 2008-02-07 04:18:33.171125000 -06:00
  author: Leaf
  email: leaf@xna-uk.net
  url: http://xna-uk.net
  content: ! 'A small comment on Bart''s comment mentioning object creation and garbage
    collection when using foreach.


    The object that is, sometimes, created is nothing to do with using foreach. It
    is simply the enumerator returned by GetEnumerator(). Many implementations return
    a new enumerator everytime GetEnumerator() is called, and often the enumerator
    is a class/reference type. Some implementations, including parts of the XNA Framework,
    use struct/value types for their enumerators as this avoids creating a new object
    on the heap.'
- created: 2008-02-08 05:17:21.159122900 -06:00
  author: Tom
  email: nospam@nospam.com
  content: ! 'Nice article.


    What advantages does this have over standard for loops? With for loops you can
    specify more conditions to stop the loop for this reason we tend not to use the
    foreach statment. How would a standard for loop compare to use of the yield keyword?'
- created: 2008-02-11 15:30:03.812625000 -06:00
  author: Joshua Flanagan
  email: josh@flimflan.com
  url: http://flimflan.com/blog
  content: ! "@Tom - I'm not sure what you mean by using a for loop. Do you mean putting
    all of the producing and consuming logic within a single for loop? The advantage
    is the separation between the logic that generates a sequence of value and the
    logic that works with those values. In my sample code, BetterGetCombinations contains
    the logic to produce a series of strings. The foreach loop in the Main method
    contains the logic of deciding when it found what it is looking for. As soon as
    the Main method decides it doesn't need any more data, it stops asking for it.
    If the Main method doesn't ask for more data, then the data will never be produced
    by BetterGetCombinations. Compare that to the original GetCombinations method
    which will ALWAYS produce all of the combinations, regardless of whether the caller
    needs them all.\nOf course, you could still use the yield magic and still use
    a for loop in Main instead of foreach, if you wanted to. It would look something
    like (replacing the foreach line in Main):\nfor (IEnumerator&lt;string&gt; enumerator
    = combinations.GetEnumerator(); enumerator.MoveNext();) {\n    string combination
    = (string) enumerator.Current;\n//... continue the rest of the loop"
- created: 2008-02-14 16:19:45.971010800 -06:00
  author: Winston Pang
  email: winstonpang@gmail.com
  url: http://www.winstonpang.net
  content: ! 'Hey Josh,


    Good post. Perhaps you should of also, went into Reflector and pasted what the
    magic underlying code that''s generated, which from what I recall is a state machine
    with lots of labels and goto''s involved to achieve the yield behavior.


    Just my 2 cents.


    Once again, good post!


    Winston'
- created: 2008-02-17 23:50:32.548375000 -06:00
  author: Luke Schafer
  email: luke.schafer@gmail.com
  url: http://www.lukeschafer.com
  content: ! "@Eric, regarding the open database connection\n\nBest way to do this
    is to create a DBConnection class (or something like that) that handles your database
    connections, and make it implement IDisposable. In the dispose method of your
    DBConnection class you can put in any cleanup you need. Now you just use:\n\nusing(
    DBConnection conn = new DBConnection())\n{\n    // Code that uses conn.\n\n}\n\nat
    the end of the using block, or exit of the scope (errors etc), the dispose method
    is called which is where you destroy the database connection. fun :)"
- created: 2008-02-20 20:45:56.595250000 -06:00
  author: Abhijeet P
  email: abhidotnet@gmail.com
  content: ! 'If you guys haven''t already then you SHOULD check out this excellent
    post Wes Dyer has on Iterators and what really goes on behind the scenes

    http://blogs.msdn.com/wesdyer/archive/2007/03/23/all-about-iterators.aspx'
- created: 2008-06-27 08:31:08.742548800 -05:00
  author: Anthony Bouch
  email: anthony@abouch.com
  url: http://www.58bits.com
  content: Saw a reference to you on a post over at CodeBetter - and then found this
    post - nice one. Yield was on my list of things to do. :-)
- created: 2010-03-06 05:55:41.421125000 -06:00
  author: trickdev
  content: Well explained.  Thanks.
- created: 2010-03-31 11:53:57.966000000 -05:00
  author: https://me.yahoo.com/a/WsEX4ScPmOlQp0iOhDE6tdd9eWKswXmI
  email: none@none.com
  url: https://me.yahoo.com/a/WsEX4ScPmOlQp0iOhDE6tdd9eWKswXmI
  content: Great explanation Joshua, very clear and helpful. The example was also
    simple and straight, even the careful names made understanding easier (the demonstration
    section wasn&#180;t really necessary, comments on code would have been enough).
    Keep the style, you're a born teacher!
- created: 2010-05-04 01:26:33.721679500 -05:00
  author: Jaishree
  email: jaishree.t@tcs.com
  content: Great Article Joshua.Its very helpful to understand the concepts very clearly.
    You've explained in a very elaborate way. Thanks.
- created: 2010-05-25 17:43:42.263952000 -05:00
  author: Chintan
  email: chin1910+flimflan@gmail.com
  content: Typos and silly mistakes aside, a VERY good read. More importantly, the
    SIMPLICITY of the example used is wonderful. Thanks for taking out time &amp;
    putting an effort to write this piece. For any such &quot;nice&quot; /&quot;hidden&quot;/&quot;not-so-popular&quot;
    but GOOD feature, such an article is what gets you started, sort of like an appetizer,
    it's up to the hungry developer to take it ahead from there on! Once again, thanks!
- created: 2010-07-02 14:08:41.466125000 -05:00
  author: Tomamais
  email: webmaster@tomasvasquez.com.br
  url: http://www.tomasvasquez.com.br/blog
  content: Amazing explanation and sample! Congratulations

---

<p>Yield is one of the coolest, yet underused, new .NET 2.0 features that you may not be familiar with. Yes, I'm talking about a 2.0 feature - even though 3.5 just came out, it is my experience that a large number of developers have still not embraced all that 2.0 gave us. Hopefully this article will help make this powerful, yet initially confusing, feature more approachable. <h2>Some background facts </h2> <p>When you "foreach" over an object (array, collection, etc), it must implement IEnumerable or IEnumerable&lt;T&gt; - the generic version which returns strongly typed objects (for the rest of this article, I'll just refer to IEnumerable).  <p>All arrays, and most collections (ArrayList, List&lt;T&gt;) implement IEnumerable, which is why you can "foreach" over them.  <p>If ALL you need to do to a collection is cycle through its members - you only need to reference it as an IEnumerable. That explains why the following code is perfectly valid: </p> <div class="wlWriterSmartContent" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E7:2b7525b1-df35-4daa-90fa-57460b4fe534" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; width: 1419px; padding-top: 0px"><pre style="background-color:White;;overflow: auto;"><div><!--

Code highlighting produced by Actipro CodeHighlighter (freeware)
http://www.CodeHighlighter.com/

--><span style="color: #000000;">IEnumerable</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> numbers </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> </span><span style="color: #0000FF;">int</span><span style="color: #000000;">[] { </span><span style="color: #800080;">1</span><span style="color: #000000;">, </span><span style="color: #800080;">2</span><span style="color: #000000;">, </span><span style="color: #800080;">3</span><span style="color: #000000;"> };
</span><span style="color: #0000FF;">foreach</span><span style="color: #000000;"> (</span><span style="color: #0000FF;">int</span><span style="color: #000000;"> i </span><span style="color: #0000FF;">in</span><span style="color: #000000;"> numbers) { Console.WriteLine(i); } 
</span></div></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>
<p>It is always better to depend on abstract types (interfaces, abstract base classes) rather than concrete types. This allows you to change the implementation of a method without impacting any of its callers. 
<p>Consider this example where CallingMethod gets a set of numbers from MethodBeingCalled. It really doesn't care if it gets an array or a List or whatever. It just does a foreach over it, which means it only needs the functionality exposed by the IEnumerable interface. </p>
<div class="wlWriterSmartContent" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E7:9ec2ba9d-2df0-4af2-a0d0-cf92aeab21bd" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre style="background-color:White;;overflow: auto;"><div><!--

Code highlighting produced by Actipro CodeHighlighter (freeware)
http://www.CodeHighlighter.com/

--><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> CallingMethod()
{
    List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> numbers </span><span style="color: #000000;">=</span><span style="color: #000000;"> MethodBeingCalled();
    </span><span style="color: #0000FF;">foreach</span><span style="color: #000000;"> (</span><span style="color: #0000FF;">int</span><span style="color: #000000;"> i </span><span style="color: #0000FF;">in</span><span style="color: #000000;"> numbers) { Console.WriteLine(i); }
}

</span><span style="color: #0000FF;">private</span><span style="color: #000000;"> List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> MethodBeingCalled()
{
    List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> numbers </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">();
    numbers.AddRange(</span><span style="color: #0000FF;">new</span><span style="color: #000000;"> </span><span style="color: #0000FF;">int</span><span style="color: #000000;">[] { </span><span style="color: #800080;">1</span><span style="color: #000000;">, </span><span style="color: #800080;">2</span><span style="color: #000000;">, </span><span style="color: #800080;">3</span><span style="color: #000000;"> });
    </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> numbers;
} 
</span></div></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>
<p>
<p>The problem with the current design is that the CallingMethod declares the list of numbers List&lt;int&gt;. That is a specific implementation detail. If CallingMethod needed to add more numbers to the list after it was returned from MethodBeingCalled, or if individual numbers were being accessed by their index, then it would make sense to declare it as a List&lt;T&gt; (or better, IList&lt;T&gt;). But it really only needs to cycle through the numbers in order. If MethodBeingCalled wanted to change its implementation to return an int[] instead, it would have to change its signature, and CallingMethod would also have to change. However, if CallingMethod had just declared its local variable as IEnumerable&lt;int&gt; (because that is the only functionality it truly depends on), then it would not have to change if MethodBeingCalled changes - as long as it still returns something that implements IEnumerable&lt;int&gt;. 
<p>So what does foreach do? It asks the IEnumerable if it has any items. If so, it gets the next item and uses it within the loop. It then asks the IEnumerable again if it has more items, gets the next one, and so on, until there are no more items. The important thing to note here is that foreach never works with the entire collection all it once - it only deals with one item at a time. 
<h2>Introducing yield </h2>
<p>How can we use all of this information? If you have a method that returns a collection of data, and you can be sure that callers are only going to be interested in looping over each item in the collection, one at a time (which is very common), you can declare your method's return value as IEnumerable&lt;T&gt;. 
<p>When you declare your method's return value as IEnumerable&lt;T&gt;, something magic happens: the C# compiler will now let you use the<b> yield</b> keyword within the body! So why does that matter? Because it allows you to take advantage of the way that foreach really works. Remember, foreach will just ask for one value at a time. When it does, it will call into your method - your method will run until it encounters a yield return statement. When it reaches a yield return statement, that value is immediately returned to the caller. In the next iteration of the caller's loop, it will ask again if there is another value, your method will start executing again, but this time<i> it will start on the line after the last yield statement that was run</i>. Yes, you read that right: execution alternates between the calling method and the method being called, all the way through the loop. This is completely different from the normal way that methods interact, where one method gives up control to another method, which doesn't return until it is completely finished executing. 
<p>This has at least 2 very important implications for the method that returns the IEnumerable&lt;T&gt;:<br>1) It does not need to build up a big list of all of the items it plans to return, holding them all in memory at the same time. If the list of items is very large, holding them all in memory at once can be a significant burden. 
<p>2) It does not necessarily need to do the work to produce all of the items in the list. If the caller breaks out of the foreach loop before the entire collection has been traversed - all of the work needed to produce the remaining items in the colleciton is avoided. Without using the yield keyword, you would have to build up the entire collection to return, even if the caller was only going to look at the first few items. 
<h2>Demonstration </h2>
<p>To illustrate the advantage of this approach, I included sample code at the bottom. You can create a new Console Application and paste this over the default Program.cs. 
<p>A method, GetCombinations returns a collection of 2 numbers combined. The caller then loops through the collection, looking for a specific combination: "13". 
<p>First, run it using GetCombinations. This is implemented the way most people would write a method that returns a collection, in .NET 1.1. The output willl look something like this (the indented output is from within GetCombinations): 
<p><font size="1"><font face="Courier New"><b>BEFORE call to GetCombinations</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Beginning execution of GetCombinations<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 33<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 23<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 13<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 32<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 22<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 12<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 21<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 11<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ending execution of GetCombinations<br><b>AFTER call to GetCombinations</b><br>Checking 33<br>Checking 23<br>Checking 13<br>Found!<br>Elapsed: 00:00:<b>08.9931583</b></font></font> 
<p>Now, comment out the line that calls GetCombinations, and uncomment the line that calls BetterGetCombinations. It is important to note that BetterGetCombinations uses the exact same algorithm as GetCombinations - given the same input, they will both return the exact same list of strings, in the same order (I've emphasized the lines that changed, in the sample code below). But since the caller is only looking for a specific combination, not all combinations need to be produced. Consider the output: 
<p><font size="1"><font face="Courier New"><b>BEFORE call to GetCombinations</b><br><b>AFTER call to GetCombinations</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Beginning execution of BetterGetCombinations &lt;-- notice that BetterGetCombinations doesn't really start until the foreach loop - NOT when the method was first called! </font></font>
<p><font size="1"><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 33<br>Checking 33<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 23<br>Checking 23<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Producing 13<br>Checking 13<br>Found!<br>Elapsed: 00:00:<b>02.9976438</b></font></font> 
<p><b>With the improved implementation that took advantage of the yield keyword, the program was able to finish its job in less than half the time!</b> It also used much less memory, as it never had to store all 9 strings in a collection. Now imagine the potential impact if GetCombinations returned a collection with thousands of entries!</p>
<h2>Sample Code</h2>
<p>Paste the code below over the default Program.cs in a new Console Application:</p>
<div class="wlWriterSmartContent" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E7:4014c03c-4e77-4dd6-a958-63b0e57df3a8" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre style="background-color:White;;overflow: auto;"><div><!--

Code highlighting produced by Actipro CodeHighlighter (freeware)
http://www.CodeHighlighter.com/

--><span style="color: #0000FF;">using</span><span style="color: #000000;"> System;
</span><span style="color: #0000FF;">using</span><span style="color: #000000;"> System.Collections.Generic;
</span><span style="color: #0000FF;">using</span><span style="color: #000000;"> System.Diagnostics;
</span><span style="color: #0000FF;">using</span><span style="color: #000000;"> System.Threading;

</span><span style="color: #0000FF;">namespace</span><span style="color: #000000;"> YieldDemo
{
    </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> Program
    {
        </span><span style="color: #0000FF;">static</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> Main()
        {
            Stopwatch timer </span><span style="color: #000000;">=</span><span style="color: #000000;"> Stopwatch.StartNew();
            Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">BEFORE call to GetCombinations</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">);

            </span><span style="color: #008000;">//</span><span style="color: #008000;">1) First try running using the GetCombinations that returns a List&lt;string&gt;</span><span style="color: #008000;">
</span><span style="color: #000000;">            List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">string</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> combinations </span><span style="color: #000000;">=</span><span style="color: #000000;"> GetCombinations(</span><span style="color: #800080;">3</span><span style="color: #000000;">, </span><span style="color: #800080;">3</span><span style="color: #000000;">);

            </span><span style="color: #008000;">//</span><span style="color: #008000;">2) After observing the output, comment out the above line, uncomment the next line, and re-run

            </span><span style="color: #008000;">//</span><span style="color: #008000;">            IEnumerable&lt;string&gt; combinations = BetterGetCombinations(3, 3);</span><span style="color: #008000;">
</span><span style="color: #000000;">
            Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">AFTER call to GetCombinations</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">);

            </span><span style="color: #0000FF;">foreach</span><span style="color: #000000;"> (</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> combination </span><span style="color: #0000FF;">in</span><span style="color: #000000;"> combinations)
            {
                Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Checking </span><span style="color: #800000;">&quot;</span><span style="color: #000000;"> </span><span style="color: #000000;">+</span><span style="color: #000000;"> combination);
                </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (combination </span><span style="color: #000000;">==</span><span style="color: #000000;"> </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">13</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">)
                {
                    Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Found!</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">);
                    </span><span style="color: #0000FF;">break</span><span style="color: #000000;">;
                }
            }
            timer.Stop();
            Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Elapsed: </span><span style="color: #800000;">&quot;</span><span style="color: #000000;"> </span><span style="color: #000000;">+</span><span style="color: #000000;"> timer.Elapsed);
        }

        </span><span style="color: #0000FF;">static</span><span style="color: #000000;"> List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">string</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> GetCombinations(</span><span style="color: #0000FF;">int</span><span style="color: #000000;"> left, </span><span style="color: #0000FF;">int</span><span style="color: #000000;"> right)
        {
            Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">\tBeginning execution of GetCombinations</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">);

            List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">string</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> output </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">string</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">();
            </span><span style="color: #0000FF;">int</span><span style="color: #000000;"> currentLeft;
            </span><span style="color: #0000FF;">int</span><span style="color: #000000;"> currentRight </span><span style="color: #000000;">=</span><span style="color: #000000;"> right;
            </span><span style="color: #0000FF;">while</span><span style="color: #000000;"> (currentRight </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">)
            {
                currentLeft </span><span style="color: #000000;">=</span><span style="color: #000000;"> left;
                </span><span style="color: #0000FF;">while</span><span style="color: #000000;"> (currentLeft </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">)
                {
                    </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> newCombinationToProduce </span><span style="color: #000000;">=</span><span style="color: #000000;"> currentLeft.ToString() </span><span style="color: #000000;">+</span><span style="color: #000000;"> currentRight;
                    Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">\tProducing </span><span style="color: #800000;">&quot;</span><span style="color: #000000;"> </span><span style="color: #000000;">+</span><span style="color: #000000;"> newCombinationToProduce);
                    Thread.Sleep(</span><span style="color: #800080;">1000</span><span style="color: #000000;">); </span><span style="color: #008000;">//</span><span style="color: #008000;"> simulate expensive process to produce a combination</span><span style="color: #008000;">
</span><span style="color: #000000;">                    output.Add(newCombinationToProduce);
                    </span><span style="color: #000000;">--</span><span style="color: #000000;">currentLeft;
                }
                </span><span style="color: #000000;">--</span><span style="color: #000000;">currentRight;
            }
            Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">\tEnding execution of GetCombinations</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">);

            </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> output;
        }

        </span><span style="color: #0000FF;">static</span><span style="color: #000000;"> IEnumerable</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">string</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> BetterGetCombinations(</span><span style="color: #0000FF;">int</span><span style="color: #000000;"> left, </span><span style="color: #0000FF;">int</span><span style="color: #000000;"> right)
        {
            Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">\tBeginning execution of BetterGetCombinations</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">);
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> NOTE The local List is not necessary in this implementation</span><span style="color: #008000;">
</span><span style="color: #000000;">            </span><span style="color: #0000FF;">int</span><span style="color: #000000;"> currentLeft;
            </span><span style="color: #0000FF;">int</span><span style="color: #000000;"> currentRight </span><span style="color: #000000;">=</span><span style="color: #000000;"> right;
            </span><span style="color: #0000FF;">while</span><span style="color: #000000;"> (currentRight </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">)
            {
                currentLeft </span><span style="color: #000000;">=</span><span style="color: #000000;"> left;
                </span><span style="color: #0000FF;">while</span><span style="color: #000000;"> (currentLeft </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">)
                {
                    </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> newCombinationToProduce </span><span style="color: #000000;">=</span><span style="color: #000000;"> currentLeft.ToString() </span><span style="color: #000000;">+</span><span style="color: #000000;"> currentRight;
                    Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">\tProducing </span><span style="color: #800000;">&quot;</span><span style="color: #000000;"> </span><span style="color: #000000;">+</span><span style="color: #000000;"> newCombinationToProduce);
                    Thread.Sleep(</span><span style="color: #800080;">1000</span><span style="color: #000000;">); </span><span style="color: #008000;">//</span><span style="color: #008000;"> simulate expensive process to produce a combination</span><span style="color: #008000;">
</span><span style="color: #000000;">                    </span><span style="color: #0000FF;">yield</span><span style="color: #000000;"> </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> newCombinationToProduce; </span><span style="color: #008000;">//</span><span style="color: #008000;"> insteading of adding to a list, just return the value</span><span style="color: #008000;">
</span><span style="color: #000000;">                    </span><span style="color: #000000;">--</span><span style="color: #000000;">currentLeft;
                }
                </span><span style="color: #000000;">--</span><span style="color: #000000;">currentRight;
            }
            Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">\tEnding execution of BetterGetCombinations</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">);
        }
    }
}</span></div></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>

---
title: Losing your (type) religion
permalink: LosingYourtypeReligion.html
layout: migrated
date: 2008-06-25
id: 354870db-1c4e-42f5-8919-6a1f95767846
published_at: 2008-06-25 02:05:02.754000000 -05:00
tags: .NET

---

<p>As I stated in my <a href="/ToVar.html" target="_blank">last post</a>, the var keyword is an acknowledgement that I do not care what the type of the variable is - I only care what it can do.</p> <h3>Into the IUknown</h3> <p>Most developer start on the path to this revelation when they discover interface-based programming. </p> <p>Consider: we need to write a method that returns a collection of strings. Callers of the method will only need to loop over the items and perform some action. The number of elements to return is not known at compile time, so we'll declare a generic List&lt;string&gt;, populate it within a loop, and then return it to the caller. </p> <p>The junior developer will declare the return type of the method as List&lt;string&gt;:</p> <p><font face="Courier New">List&lt;string&gt; GetNames(){}</font></p> <p>Acknowledging that callers should not be bothered with having to know an implementation detail (the fact that a List was used instead of a fixed-sized array), and knowing that they only need to loop over the returned items, a more experienced developer might declare the method:</p> <p><font face="Courier New">IEnumerable&lt;string&gt; GetNames() {}</font></p> <p>Which means any variable the receives the return value will also be typed as IEnumerable&lt;string&gt;:</p> <p><font face="Courier New">IEnumerable&lt;string&gt; names = GetNames();</font></p> <p>Here's the kicker - in <em>both</em> scenarios, the GetNames method is really returning an object of type List&lt;string&gt;! When the supposedly more experienced developer chooses to return a more abstract type like IEnumerable&lt;string&gt;, type information is lost. Yikes! The <em>names</em> local variable above holds a List&lt;string&gt; instance, but you (the client developer) don't know it. As scary as that might sound, you probably realize that you don't care. As long as you can do the things you need to do with <em>names</em> (loop over it), you are happy.</p> <h3>Walking like a duck</h3> <p>Now let's take that train of thought and consider <a href="http://en.wikipedia.org/wiki/Duck_typing" target="_blank">duck typing</a> in a dynamic language like Python. I can declare the following method:</p> <p><font face="Courier New">def Recycle(service):<br>&nbsp;&nbsp;&nbsp; service.Stop()<br>&nbsp;&nbsp;&nbsp; service.Start()</font><br></p> <p>It takes a single parameter named <em>service</em>. What is the type of the parameter that is expected? I don't know. And after the initial anxiety settles, there is the liberating realization that I don't have to care! All I know, or care, is that any object instance that is passed to this method must implement a Start() and a Stop() method. The same method can be used with instances of a Lawnmower, AuditLogger, or SongPlayer class (assuming they all have Start and Stop methods). </p> <h3>Getting closer to the goal</h3> <p>Let me be clear - I am not suggesting that implicit typing in C# 3.0 is the same as duck typing. What I am suggesting is that the 2 examples above are points along the "progression of understanding" of the same concept: it is the behavior of an object that really matters, as opposed to the type name that is attached to it. Interface-based programming is near the start. Implicit typing is further along the progression. Duck typing is closer to the end.</p> <p>I think we will find that programmers who have been exposed to and understand languages which support duck typing will be more likely to be comfortable with and embrace the var keyword. They have already made the mental leap that type information serves the computer more than it serves the human. If you haven't yet, do yourself a favor and learn a dynamic programming language, even if you know you will continue to spend your days with static typing.</p>
